// Generated by CoffeeScript 1.10.0

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */


/*
 * Define the Esprima node structure for JavaScript parse trees.  This is mostly
 * identical to the SpiderMonkey API defined at
 * https://developer.mozilla.org/en/SpiderMonkey/Parser_API without any of the
 * SpiderMonkey specifics and a few simplifications made by Esprima (i.e. it
 * doesn't have separate objects for operator types, etc.).
 *
 * It's important to note that the Esprima parse tree will return object literals
 * and not instances of these types.  They're provided primarily for reference
 * and for easily constructing new subtrees during transformations by visitors.
 */


/* Get the base Node and Visitor classes. */

(function() {
  var ArrayExpression, ArrayPattern, AssignmentExpression, BinaryExpression, BlockStatement, BreakStatement, CallExpression, CatchClause, ConditionalExpression, ContinueStatement, DebuggerStatement, Declaration, DoWhileStatement, EmptyStatement, Expression, ExpressionStatement, ForInStatement, ForStatement, Function, FunctionDeclaration, FunctionExpression, Identifier, IfStatement, JavaScriptNode, JavaScriptVisitor, LabeledStatement, Literal, LogicalExpression, MemberExpression, NewExpression, Node, ObjectExpression, ObjectPattern, Pattern, Program, ReturnStatement, SequenceExpression, Statement, SwitchCase, SwitchStatement, ThisExpression, ThrowStatement, TryStatement, UnaryExpression, UpdateExpression, VariableDeclaration, VariableDeclarator, Visitor, WhileStatement, WithStatement, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./Node'), Node = ref.Node, Visitor = ref.Visitor;


  /*
   * Base node for all JavaScript nodes.
   */

  exports.JavaScriptNode = JavaScriptNode = (function(superClass) {
    extend(JavaScriptNode, superClass);

    function JavaScriptNode() {
      JavaScriptNode.__super__.constructor.call(this);
    }

    return JavaScriptNode;

  })(Node);


  /*
   * Base visitor for all JavaScript nodes.
   */

  exports.JavaScriptVisitor = JavaScriptVisitor = (function(superClass) {
    extend(JavaScriptVisitor, superClass);

    function JavaScriptVisitor() {
      JavaScriptVisitor.__super__.constructor.call(this);
    }

    JavaScriptVisitor.prototype.JavaScriptNode = function(node) {
      return node;
    };

    return JavaScriptVisitor;

  })(Visitor);


  /*
   * A complete program source tree.
   */

  exports.Program = Program = (function(superClass) {
    extend(Program, superClass);


    /*
     * @elements: [Statement]
     */

    function Program(elements) {
      this.elements = elements;
      Program.__super__.constructor.call(this);
    }

    return Program;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Program = function(node) {
    node = this.JavaScriptNode(node);
    node.elements = this.visit(node.elements);
    return node;
  };


  /*
   * A function declaration or expression. The body of the function is a  block
   * statement.
   */

  exports.Function = Function = (function(superClass) {
    extend(Function, superClass);


    /*
     * @id: Identifier | null
     * @params: [Pattern]
     * @body: BlockStatement
     */

    function Function(id, params, body) {
      this.id = id;
      this.params = params;
      this.body = body;
      Function.__super__.constructor.call(this);
    }

    return Function;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Function = function(node) {
    node = this.JavaScriptNode(node);
    node.id = this.visit(node.id);
    node.params = this.visit(node.params);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * Any statement.
   */

  exports.Statement = Statement = (function(superClass) {
    extend(Statement, superClass);

    function Statement() {
      Statement.__super__.constructor.call(this);
    }

    return Statement;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Statement = function(node) {
    node = this.JavaScriptNode(node);
    return node;
  };


  /*
   * An empty statement, i.e., a solitary semicolon.
   */

  exports.EmptyStatement = EmptyStatement = (function(superClass) {
    extend(EmptyStatement, superClass);

    function EmptyStatement() {
      EmptyStatement.__super__.constructor.call(this);
    }

    return EmptyStatement;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.EmptyStatement = function(node) {
    node = this.JavaScriptNode(node);
    return node;
  };


  /*
   * A block statement, i.e., a sequence of statements surrounded by braces.
   */

  exports.BlockStatement = BlockStatement = (function(superClass) {
    extend(BlockStatement, superClass);


    /*
     * @body: [Statement]
     */

    function BlockStatement(body) {
      this.body = body;
      BlockStatement.__super__.constructor.call(this);
    }

    return BlockStatement;

  })(Statement);

  JavaScriptVisitor.prototype.BlockStatement = function(node) {
    node = this.Statement(node);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * An expression statement, i.e., a statement consisting of a single expression.
   */

  exports.ExpressionStatement = ExpressionStatement = (function(superClass) {
    extend(ExpressionStatement, superClass);

    function ExpressionStatement() {
      ExpressionStatement.__super__.constructor.call(this);
    }

    return ExpressionStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ExpressionStatement = function(node) {
    node = this.Statement(node);
    return node;
  };


  /*
   * An if statement.
   */

  exports.IfStatement = IfStatement = (function(superClass) {
    extend(IfStatement, superClass);


    /*
     * @test: Expression
     * @consequent: Statement
     * @alternate: Statement | null
     */

    function IfStatement(test, consequent, alternate) {
      this.test = test;
      this.consequent = consequent;
      this.alternate = alternate;
      IfStatement.__super__.constructor.call(this);
    }

    return IfStatement;

  })(Statement);

  JavaScriptVisitor.prototype.IfStatement = function(node) {
    node = this.Statement(node);
    node.test = this.visit(node.test);
    node.consequent = this.visit(node.consequent);
    node.alternate = this.visit(node.alternate);
    return node;
  };


  /*
   * A labeled statement, i.e., a statement prefixed by a break/continue label.
   */

  exports.LabeledStatement = LabeledStatement = (function(superClass) {
    extend(LabeledStatement, superClass);


    /*
     * @label: Identifier
     * @body: Statement
     */

    function LabeledStatement(label, body) {
      this.label = label;
      this.body = body;
      LabeledStatement.__super__.constructor.call(this);
    }

    return LabeledStatement;

  })(Statement);

  JavaScriptVisitor.prototype.LabeledStatement = function(node) {
    node = this.Statement(node);
    node.label = this.visit(node.label);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A break statement.
   */

  exports.BreakStatement = BreakStatement = (function(superClass) {
    extend(BreakStatement, superClass);


    /*
     * @label: Identifier | null
     */

    function BreakStatement(label) {
      this.label = label;
      BreakStatement.__super__.constructor.call(this);
    }

    return BreakStatement;

  })(Statement);

  JavaScriptVisitor.prototype.BreakStatement = function(node) {
    node = this.Statement(node);
    node.label = this.visit(node.label);
    return node;
  };


  /*
  A continue statement.
   */

  exports.ContinueStatement = ContinueStatement = (function(superClass) {
    extend(ContinueStatement, superClass);


    /*
    @label: Identifier | null
     */

    function ContinueStatement(label) {
      this.label = label;
      ContinueStatement.__super__.constructor.call(this);
    }

    return ContinueStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ContinueStatement = function(node) {
    node = this.Statement(node);
    node.label = this.visit(node.label);
    return node;
  };


  /*
   * A with statement.
   */

  exports.WithStatement = WithStatement = (function(superClass) {
    extend(WithStatement, superClass);


    /*
     * @object: Expression
     * @body: Statement
     */

    function WithStatement(object, body) {
      this.object = object;
      this.body = body;
      WithStatement.__super__.constructor.call(this);
    }

    return WithStatement;

  })(Statement);

  JavaScriptVisitor.prototype.WithStatement = function(node) {
    node = this.Statement(node);
    node.object = this.visit(node.object);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A switch statement.
   */

  exports.SwitchStatement = SwitchStatement = (function(superClass) {
    extend(SwitchStatement, superClass);


    /*
     * @discriminant: Expression
     * @cases: [SwitchCase]
     */

    function SwitchStatement(discriminant, cases) {
      this.discriminant = discriminant;
      this.cases = cases;
      SwitchStatement.__super__.constructor.call(this);
    }

    return SwitchStatement;

  })(Statement);

  JavaScriptVisitor.prototype.SwitchStatement = function(node) {
    node = this.Statement(node);
    node.discriminant = this.visit(node.discriminant);
    node.cases = this.visit(node.cases);
    return node;
  };


  /*
   * A return statement.
   */

  exports.ReturnStatement = ReturnStatement = (function(superClass) {
    extend(ReturnStatement, superClass);


    /*
     * @argument: Expression | null
     */

    function ReturnStatement(argument) {
      this.argument = argument;
      ReturnStatement.__super__.constructor.call(this);
    }

    return ReturnStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ReturnStatement = function(node) {
    node = this.Statement(node);
    node.argument = this.visit(node.argument);
    return node;
  };


  /*
   * A throw statement.
   */

  exports.ThrowStatement = ThrowStatement = (function(superClass) {
    extend(ThrowStatement, superClass);


    /*
     * @argument: Expression
     */

    function ThrowStatement(argument) {
      this.argument = argument;
      ThrowStatement.__super__.constructor.call(this);
    }

    return ThrowStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ThrowStatement = function(node) {
    node = this.Statement(node);
    node.argument = this.visit(node.argument);
    return node;
  };


  /*
   * A try statement.
   */

  exports.TryStatement = TryStatement = (function(superClass) {
    extend(TryStatement, superClass);


    /*
     * @block: BlockStatement
     * @handlers: [CatchClause]
     * @finalizer: BlockStatement | null
     */

    function TryStatement(block, handlers, finalizer) {
      this.block = block;
      this.handlers = handlers;
      this.finalizer = finalizer;
      TryStatement.__super__.constructor.call(this);
    }

    return TryStatement;

  })(Statement);

  JavaScriptVisitor.prototype.TryStatement = function(node) {
    node = this.Statement(node);
    node.block = this.visit(node.block);
    node.handlers = this.visit(node.handlers);
    node.finalizer = this.visit(node.finalizer);
    return node;
  };


  /*
   * A while statement.
   */

  exports.WhileStatement = WhileStatement = (function(superClass) {
    extend(WhileStatement, superClass);


    /*
     * @test: Expression
     * @body: Statement
     */

    function WhileStatement(test, body) {
      this.test = test;
      this.body = body;
      WhileStatement.__super__.constructor.call(this);
    }

    return WhileStatement;

  })(Statement);

  JavaScriptVisitor.prototype.WhileStatement = function(node) {
    node = this.Statement(node);
    node.test = this.visit(node.test);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A do/while statement.
   */

  exports.DoWhileStatement = DoWhileStatement = (function(superClass) {
    extend(DoWhileStatement, superClass);


    /*
     * @body: Statement
     * @test: Expression
     */

    function DoWhileStatement(body, test) {
      this.body = body;
      this.test = test;
      DoWhileStatement.__super__.constructor.call(this);
    }

    return DoWhileStatement;

  })(Statement);

  JavaScriptVisitor.prototype.DoWhileStatement = function(node) {
    node = this.Statement(node);
    node.body = this.visit(node.body);
    node.test = this.visit(node.test);
    return node;
  };


  /*
   * A for statement.
   */

  exports.ForStatement = ForStatement = (function(superClass) {
    extend(ForStatement, superClass);


    /*
     * @init: VariableDeclaration | Expression | null
     * @test: Expression | null
     * @update: Expression | null
     * @body: Statement
     */

    function ForStatement(init, test, update, body) {
      this.init = init;
      this.test = test;
      this.update = update;
      this.body = body;
      ForStatement.__super__.constructor.call(this);
    }

    return ForStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ForStatement = function(node) {
    node = this.Statement(node);
    node.init = this.visit(node.init);
    node.test = this.visit(node.test);
    node.update = this.visit(node.update);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A for/in statement, or, if each is true, a for each/in statement.
   */

  exports.ForInStatement = ForInStatement = (function(superClass) {
    extend(ForInStatement, superClass);


    /*
     * @left: VariableDeclaration |  Expression
     * @right: Expression
     * @body: Statement
     */

    function ForInStatement(left, right, body) {
      this.left = left;
      this.right = right;
      this.body = body;
      ForInStatement.__super__.constructor.call(this);
    }

    return ForInStatement;

  })(Statement);

  JavaScriptVisitor.prototype.ForInStatement = function(node) {
    node = this.Statement(node);
    node.left = this.visit(node.left);
    node.right = this.visit(node.right);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A debugger statement.
   */

  exports.DebuggerStatement = DebuggerStatement = (function(superClass) {
    extend(DebuggerStatement, superClass);

    function DebuggerStatement() {
      DebuggerStatement.__super__.constructor.call(this);
    }

    return DebuggerStatement;

  })(Statement);

  JavaScriptVisitor.prototype.DebuggerStatement = function(node) {
    node = this.Statement(node);
    return node;
  };


  /*
   * Any declaration node. Note that declarations are considered statements; this
   * is because declarations can appear in any statement context in the language.
   */

  exports.Declaration = Declaration = (function(superClass) {
    extend(Declaration, superClass);

    function Declaration() {
      Declaration.__super__.constructor.call(this);
    }

    return Declaration;

  })(Statement);

  JavaScriptVisitor.prototype.Declaration = function(node) {
    node = this.Statement(node);
    return node;
  };


  /*
   * A function declaration.  Note: The id field cannot be null.
   */

  exports.FunctionDeclaration = FunctionDeclaration = (function(superClass) {
    extend(FunctionDeclaration, superClass);


    /*
     * @id: Identifier
     * @params: [ Pattern ]
     * @body: BlockStatement | Expression
     */

    function FunctionDeclaration(id, params, body) {
      this.id = id;
      this.params = params;
      this.body = body;
      FunctionDeclaration.__super__.constructor.call(this);
    }

    return FunctionDeclaration;

  })(Declaration);

  JavaScriptVisitor.prototype.FunctionDeclaration = function(node) {
    node = this.Declaration(node);
    node.id = this.visit(node.id);
    node.params = this.visit(node.params);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A variable declaration, via one of var, let, or const.
   */

  exports.VariableDeclaration = VariableDeclaration = (function(superClass) {
    extend(VariableDeclaration, superClass);


    /*
     * @declarations: [ VariableDeclarator ]
     * @kind: "var"
     */

    function VariableDeclaration(declarations, kind) {
      this.declarations = declarations;
      this.kind = kind;
      VariableDeclaration.__super__.constructor.call(this);
    }

    return VariableDeclaration;

  })(Declaration);

  JavaScriptVisitor.prototype.VariableDeclaration = function(node) {
    node = this.Declaration(node);
    node.declarations = this.visit(node.declarations);
    return node;
  };


  /*
   * A variable declarator.  Note: The id field cannot be null.
   */

  exports.VariableDeclarator = VariableDeclarator = (function(superClass) {
    extend(VariableDeclarator, superClass);


    /*
     * @id: Pattern
     * @init: Expression | null
     */

    function VariableDeclarator(id, init) {
      this.id = id;
      this.init = init;
      VariableDeclarator.__super__.constructor.call(this);
    }

    return VariableDeclarator;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.VariableDeclarator = function(node) {
    node = this.JavaScriptNode(node);
    node.id = this.visit(node.id);
    node.init = this.visit(node.init);
    return node;
  };


  /*
   * Any expression node. Since the left-hand side of an assignment may be any
   * expression in general, an expression can also be a pattern.
   */

  exports.Expression = Expression = (function(superClass) {
    extend(Expression, superClass);

    function Expression() {
      return Expression.__super__.constructor.apply(this, arguments);
    }

    Expression.prototype.constuctor = function() {
      return Expression.__super__.constuctor.call(this);
    };

    return Expression;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Expression = function(node) {
    node = this.JavaScriptNode(node);
    return node;
  };


  /*
   * A this expression.
   */

  exports.ThisExpression = ThisExpression = (function(superClass) {
    extend(ThisExpression, superClass);

    function ThisExpression() {
      ThisExpression.__super__.constructor.call(this);
    }

    return ThisExpression;

  })(Expression);

  JavaScriptVisitor.prototype.ThisExpression = function(node) {
    node = this.Expression(node);
    return node;
  };


  /*
   * An array expression.
   */

  exports.ArrayExpression = ArrayExpression = (function(superClass) {
    extend(ArrayExpression, superClass);


    /*
     * @elements: [ Expression | null ]
     */

    function ArrayExpression(elements) {
      this.elements = elements;
      ArrayExpression.__super__.constructor.call(this);
    }

    return ArrayExpression;

  })(Expression);

  JavaScriptVisitor.prototype.ArrayExpression = function(node) {
    node = this.Expression(node);
    node.elements = this.visit(node.elements);
    return node;
  };


  /*
   * An object expression. A literal property in an object expression can have
   * either a string or number as its value.  Ordinary property initializers have a
   * kind value "init"; getters and setters have the kind values "get" and "set",
   * respectively.
   */

  exports.ObjectExpression = ObjectExpression = (function(superClass) {
    extend(ObjectExpression, superClass);


    /*
     * @properties: [ { key: Literal | Identifier,
     *                 value: Expression,
     *                 kind: "init" | "get" | "set" } ];
     */

    function ObjectExpression(properties) {
      this.properties = properties;
      ObjectExpression.__super__.constructor.call(this);
    }

    return ObjectExpression;

  })(Expression);

  JavaScriptVisitor.prototype.ObjectExpression = function(node) {
    var i, len, ref1, setter;
    node = this.Expression(node);
    ref1 = node.properties;
    for (i = 0, len = ref1.length; i < len; i++) {
      setter = ref1[i];
      setter.key = this.visit(setter.key);
      setter.value = this.visit(setter.value);
    }
    return node;
  };


  /*
   * A function expression.
   */

  exports.FunctionExpression = FunctionExpression = (function(superClass) {
    extend(FunctionExpression, superClass);


    /*
     * @id: Identifier | null
     * @params: [ Pattern ]
     * @body: BlockStatement | Expression
     */

    function FunctionExpression(id, params, body) {
      this.id = id;
      this.params = params;
      this.body = body;
      FunctionExpression.__super__.constructor.call(this);
    }

    return FunctionExpression;

  })(Expression);

  JavaScriptVisitor.prototype.FunctionExpression = function(node) {
    node = this.Expression(node);
    node.id = this.visit(node.id);
    node.params = this.visit(node.params);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * A sequence expression, i.e., a comma-separated sequence of expressions.
   */

  exports.SequenceExpression = SequenceExpression = (function(superClass) {
    extend(SequenceExpression, superClass);


    /*
     * @expressions: [ Expression ]
     */

    function SequenceExpression(expressions) {
      this.expressions = expressions;
      SequenceExpression.__super__.constructor.call(this);
    }

    return SequenceExpression;

  })(Expression);

  JavaScriptVisitor.prototype.SequenceExpression = function(node) {
    node = this.Expression(node);
    node.expressions = this.visit(node.expressions);
    return node;
  };


  /*
   * A unary operator expression.
   */

  exports.UnaryExpression = UnaryExpression = (function(superClass) {
    extend(UnaryExpression, superClass);


    /*
     * @operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete"
     * @prefix: boolean
     * @argument: Expression
     */

    function UnaryExpression(operator, prefix, argument) {
      this.operator = operator;
      this.prefix = prefix;
      this.argument = argument;
      UnaryExpression.__super__.constructor.call(this);
    }

    return UnaryExpression;

  })(Expression);

  JavaScriptVisitor.prototype.UnaryExpression = function(node) {
    node = this.Expression(node);
    node.argument = this.visit(node.argument);
    return node;
  };


  /*
   * A binary operator expression.
   */

  exports.BinaryExpression = BinaryExpression = (function(superClass) {
    extend(BinaryExpression, superClass);


    /*
     * @operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">="
     *     | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%"
     *     | "|" | "&" | "^" | "in" | "instanceof" | ".."
     * @left: Expression
     * @right: Expression
     */

    function BinaryExpression(operator, left, right) {
      this.operator = operator;
      this.left = left;
      this.right = right;
      BinaryExpression.__super__.constructor.call(this);
    }

    return BinaryExpression;

  })(Expression);

  JavaScriptVisitor.prototype.BinaryExpression = function(node) {
    node = this.Expression(node);
    node.left = this.visit(node.left);
    node.right = this.visit(node.right);
    return node;
  };


  /*
   * An assignment operator expression.
   */

  exports.AssignmentExpression = AssignmentExpression = (function(superClass) {
    extend(AssignmentExpression, superClass);


    /*
     * @operator: "=" | "+=" | "-=" | "*=" | "/=" | "%="
     *     | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=";
     * @left: Expression
     * @right: Expression
     */

    function AssignmentExpression(operator, left, right) {
      this.operator = operator;
      this.left = left;
      this.right = right;
      AssignmentExpression.__super__.constructor.call(this);
    }

    return AssignmentExpression;

  })(Expression);

  JavaScriptVisitor.prototype.AssignmentExpression = function(node) {
    node = this.Expression(node);
    node.left = this.visit(node.left);
    node.right = this.visit(node.right);
    return node;
  };


  /*
   * An update (increment or decrement) operator expression.
   */

  exports.UpdateExpression = UpdateExpression = (function(superClass) {
    extend(UpdateExpression, superClass);


    /*
     * @operator: "++" | "--"
     * @argument: Expression
     * @prefix: boolean
     */

    function UpdateExpression(operator, argument, prefix) {
      this.operator = operator;
      this.argument = argument;
      this.prefix = prefix;
      UpdateExpression.__super__.constructor.call(this);
    }

    return UpdateExpression;

  })(Expression);

  JavaScriptVisitor.prototype.UpdateExpression = function(node) {
    node = this.Expression(node);
    node.argument = this.visit(node.argument);
    return node;
  };


  /*
   * A logical operator expression.
   */

  exports.LogicalExpression = LogicalExpression = (function(superClass) {
    extend(LogicalExpression, superClass);


    /*
     * @operator: "||" | "&&"
     * @left: Expression
     * @right: Expression
     */

    function LogicalExpression(operator, left, right) {
      this.operator = operator;
      this.left = left;
      this.right = right;
      LogicalExpression.__super__.constructor.call(this);
    }

    return LogicalExpression;

  })(Expression);

  JavaScriptVisitor.prototype.LogicalExpression = function(node) {
    node = this.Expression(node);
    node.left = this.visit(node.left);
    node.right = this.visit(node.right);
    return node;
  };


  /*
   * A conditional expression, i.e., a ternary ?/: expression.
   */

  exports.ConditionalExpression = ConditionalExpression = (function(superClass) {
    extend(ConditionalExpression, superClass);


    /*
     * @test: Expression
     * @alternate: Expression
     * @consequent: Expression
     */

    function ConditionalExpression(test, alternate, consequent) {
      this.test = test;
      this.alternate = alternate;
      this.consequent = consequent;
      ConditionalExpression.__super__.constructor.call(this);
    }

    return ConditionalExpression;

  })(Expression);

  JavaScriptVisitor.prototype.ConditionalExpression = function(node) {
    node = this.Expression(node);
    node.test = this.visit(node.test);
    node.alternate = this.visit(node.alternate);
    node.consequent = this.visit(node.consequent);
    return node;
  };


  /*
   * A new expression.
   */

  exports.NewExpression = NewExpression = (function(superClass) {
    extend(NewExpression, superClass);


    /*
     * @callee: Expression
     * @arguments: [ Expression ] | null
     */

    function NewExpression(callee, _arguments) {
      this.callee = callee;
      this["arguments"] = _arguments;
      NewExpression.__super__.constructor.call(this);
    }

    return NewExpression;

  })(Expression);

  JavaScriptVisitor.prototype.NewExpression = function(node) {
    node = this.Expression(node);
    node.callee = this.visit(node.callee);
    node["arguments"] = this.visit(node["arguments"]);
    return node;
  };


  /*
   * A function or method call expression.
   */

  exports.CallExpression = CallExpression = (function(superClass) {
    extend(CallExpression, superClass);


    /*
     * @callee: Expression
     * @arguments: [ Expression ]
     */

    function CallExpression(callee, _arguments) {
      this.callee = callee;
      this["arguments"] = _arguments;
      CallExpression.__super__.constructor.call(this);
    }

    return CallExpression;

  })(Expression);

  JavaScriptVisitor.prototype.CallExpression = function(node) {
    node = this.Expression(node);
    node.callee = this.visit(node.callee);
    node["arguments"] = this.visit(node["arguments"]);
    return node;
  };


  /*
   * A member expression. If computed === true, the node corresponds to a computed
   * e1[e2] expression and property is an Expression. If computed === false, the
   * node corresponds to a static e1.x expression and property is an Identifier.
   */

  exports.MemberExpression = MemberExpression = (function(superClass) {
    extend(MemberExpression, superClass);


    /*
     * @object: Expression
     * @property: Identifier | Expression
     * @computed : boolean
     */

    function MemberExpression(object, property, computed) {
      this.object = object;
      this.property = property;
      this.computed = computed;
      MemberExpression.__super__.constructor.call(this);
    }

    return MemberExpression;

  })(Expression);

  JavaScriptVisitor.prototype.MemberExpression = function(node) {
    node = this.Expression(node);
    node.object = this.visit(node.object);
    node.property = this.visit(node.property);
    return node;
  };


  /*
   * JavaScript 1.7 introduced destructuring assignment and binding forms.  All
   * binding forms (such as function parameters, variable declarations, and catch
   * block headers), accept array and object destructuring patterns in addition to
   * plain identifiers. The left-hand sides of assignment expressions can be
   * arbitrary expressions, but in the case where the expression is an object or
   * array literal, it is interpreted by SpiderMonkey as a destructuring pattern.
   *
   * Since the left-hand side of an assignment can in general be any expression, in
   * an assignment context, a pattern can be any expression. In binding positions
   * (such as function parameters, variable declarations, and catch headers),
   * patterns can only be identifiers in the base case, not arbitrary expressions.
   */

  exports.Pattern = Pattern = (function(superClass) {
    extend(Pattern, superClass);

    function Pattern() {
      Pattern.__super__.constructor.call(this);
    }

    return Pattern;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Pattern = function(node) {
    node = this.JavaScriptNode(node);
    return node;
  };


  /*
   * An object-destructuring pattern. A literal property in an object pattern can
   * have either a string or number as its value.
   */

  exports.ObjectPattern = ObjectPattern = (function(superClass) {
    extend(ObjectPattern, superClass);


    /*
     * @properties: [ { key: Literal | Identifier, value: Pattern } ]
     */

    function ObjectPattern(properties) {
      this.properties = properties;
      ObjectPattern.__super__.constructor.call(this);
    }

    return ObjectPattern;

  })(Pattern);

  JavaScriptVisitor.prototype.ObjectPattern = function(node) {
    var i, len, ref1, setter;
    node = this.Pattern(node);
    ref1 = node.properties;
    for (i = 0, len = ref1.length; i < len; i++) {
      setter = ref1[i];
      setter.key = this.visit(setter.key);
      setter.value = this.visit(setter.value);
    }
    return node;
  };


  /*
   * An array-destructuring pattern.
   */

  exports.ArrayPattern = ArrayPattern = (function(superClass) {
    extend(ArrayPattern, superClass);


    /*
     * @elements: [ Pattern | null ]
     */

    function ArrayPattern(elements) {
      this.elements = elements;
      ArrayPattern.__super__.constructor.call(this);
    }

    return ArrayPattern;

  })(Pattern);

  JavaScriptVisitor.prototype.ArrayPattern = function(node) {
    node = this.Pattern(node);
    node.elements = this.visit(node.elements);
    return node;
  };


  /*
   * A case (if test is an Expression) or default (if test === null) clause in the
   * body of a switch statement.
   */

  exports.SwitchCase = SwitchCase = (function(superClass) {
    extend(SwitchCase, superClass);


    /*
     * @test: Expression | null
     * @consequent: [ Statement ]
     */

    function SwitchCase(test, consequent) {
      this.test = test;
      this.consequent = consequent;
      SwitchCase.__super__.constructor.call(this);
    }

    return SwitchCase;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.SwitchCase = function(node) {
    node = this.JavaScriptNode(node);
    node.test = this.visit(node.test);
    node.consequent = this.visit(node.consequent);
    return node;
  };


  /*
   * A catch clause following a try block. The optional guard property corresponds
   * to the optional expression guard on the bound variable.
   */

  exports.CatchClause = CatchClause = (function(superClass) {
    extend(CatchClause, superClass);


    /*
     * @param: Pattern
     * @body: BlockStatement
     */

    function CatchClause(param, body) {
      this.param = param;
      this.body = body;
      CatchClause.__super__.constructor.call(this);
    }

    return CatchClause;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.CatchClause = function(node) {
    node = this.JavaScriptNode(node);
    node.param = this.visit(node.param);
    node.body = this.visit(node.body);
    return node;
  };


  /*
   * An identifier. Note that an identifier may be an expression or a destructuring
   * pattern.
   */

  exports.Identifier = Identifier = (function(superClass) {
    extend(Identifier, superClass);


    /*
     * @name: string
     */

    function Identifier(name) {
      this.name = name;
      Identifier.__super__.constructor.call(this);
    }

    return Identifier;

  })(JavaScriptNode);

  JavaScriptVisitor.prototype.Identifier = function(node) {
    node = this.JavaScriptNode(node);
    return node;
  };


  /*
   * A literal token. Note that a literal can be an expression.
   */

  exports.Literal = Literal = (function(superClass) {
    extend(Literal, superClass);


    /*
     * @value: string | boolean | null | number | RegExp
     */

    function Literal(value) {
      this.value = value;
      Literal.__super__.constructor.call(this);
    }

    return Literal;

  })(Expression);

  JavaScriptVisitor.prototype.Literal = function(node) {
    node = this.Expression(node);
    return node;
  };

}).call(this);
