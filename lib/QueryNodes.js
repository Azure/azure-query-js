// Generated by CoffeeScript 1.10.0

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */


/*
 * Define a low level intermediate query expression language that we can
 * translate other expressions languages (like JavaScript) into.
 */


/* Get the base Node class. */

(function() {
  var BinaryExpression, ConstantExpression, InvocationExpression, LiteralExpression, MemberExpression, Node, QueryExpression, QueryExpressionVisitor, UnaryExpression, Visitor, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./Node'), Node = ref.Node, Visitor = ref.Visitor;


  /*
   * Provides the base class from which the classes that represent expression tree
   * nodes are derived.
   */

  exports.QueryExpression = QueryExpression = (function(superClass) {
    extend(QueryExpression, superClass);

    function QueryExpression() {
      QueryExpression.__super__.constructor.call(this);
    }


    /*
     * Group a sequence of clauses together with a given operator (like And
     * or Or).
     */

    QueryExpression.groupClauses = function(operator, clauses) {
      var combine;
      combine = function(left, right) {
        if (!left) {
          return right;
        } else if (!right) {
          return left;
        } else {
          return new BinaryExpression(operator, left, right);
        }
      };
      return clauses.reduce(combine, null);
    };

    return QueryExpression;

  })(Node);

  exports.QueryExpressionVisitor = QueryExpressionVisitor = (function(superClass) {
    extend(QueryExpressionVisitor, superClass);

    function QueryExpressionVisitor() {
      QueryExpressionVisitor.__super__.constructor.call(this);
    }

    QueryExpressionVisitor.prototype.QueryExpression = function(node) {
      return node;
    };

    return QueryExpressionVisitor;

  })(Visitor);


  /*
   * Represents an expression that has a constant value.
   */

  exports.ConstantExpression = ConstantExpression = (function(superClass) {
    extend(ConstantExpression, superClass);


    /*
     * @value: The value of the constant expression.
     */

    function ConstantExpression(value) {
      this.value = value;
      ConstantExpression.__super__.constructor.call(this);
    }

    return ConstantExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.ConstantExpression = function(node) {
    return this.QueryExpression(node);
  };


  /*
   * Represents accessing a field.
   */

  exports.MemberExpression = MemberExpression = (function(superClass) {
    extend(MemberExpression, superClass);


    /*
     * @member: Gets the field to be accessed.
     */

    function MemberExpression(member) {
      this.member = member;
      MemberExpression.__super__.constructor.call(this);
    }

    return MemberExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.MemberExpression = function(node) {
    return this.QueryExpression(node);
  };


  /*
   * Represents an expression that has a binary operator.
   */

  exports.BinaryExpression = BinaryExpression = (function(superClass) {
    extend(BinaryExpression, superClass);


    /*
     * @operator: The operator of the binary expression.
     * @left: The left operand of the binary operation.
     * @right: The right operand of the binary operation.
     */

    function BinaryExpression(operator1, left1, right1) {
      this.operator = operator1;
      this.left = left1;
      this.right = right1;
      BinaryExpression.__super__.constructor.call(this);
    }

    return BinaryExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.BinaryExpression = function(node) {
    node = this.QueryExpression(node);
    node.left = this.visit(node.left);
    node.right = this.visit(node.right);
    return node;
  };


  /*
   * Represents the known binary operators.
   */

  exports.BinaryOperators = {
    And: 'And',
    Or: 'Or',
    Add: 'Add',
    Subtract: 'Subtract',
    Multiply: 'Multiply',
    Divide: 'Divide',
    Modulo: 'Modulo',
    GreaterThan: 'GreaterThan',
    GreaterThanOrEqual: 'GreaterThanOrEqual',
    LessThan: 'LessThan',
    LessThanOrEqual: 'LessThanOrEqual',
    NotEqual: 'NotEqual',
    Equal: 'Equal'
  };


  /*
   * Represents the known unary operators.
   */

  exports.UnaryExpression = UnaryExpression = (function(superClass) {
    extend(UnaryExpression, superClass);


    /*
     * @operator: The operator of the unary expression.
     * @operand: The operand of the unary expression.
     */

    function UnaryExpression(operator1, operand) {
      this.operator = operator1;
      this.operand = operand;
      UnaryExpression.__super__.constructor.call(this);
    }

    return UnaryExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.UnaryExpression = function(node) {
    node = this.QueryExpression(node);
    node.operand = this.visit(node.operand);
    return node;
  };


  /*
   * Represents the known unary operators.
   */

  exports.UnaryOperators = {
    Not: 'Not',
    Negate: 'Negate',
    Increment: 'Increment',
    Decrement: 'Decrement'
  };


  /*
   * Represents a method invocation.
   */

  exports.InvocationExpression = InvocationExpression = (function(superClass) {
    extend(InvocationExpression, superClass);


    /*
     * @method: The name of the method to invoke.
     * @args: The arguments to the method.
     */

    function InvocationExpression(method, args) {
      this.method = method;
      this.args = args;
      InvocationExpression.__super__.constructor.call(this);
    }

    return InvocationExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.InvocationExpression = function(node) {
    node = this.QueryExpression(node);
    node.args = this.visit(node.args);
    return node;
  };


  /*
   * Represents the known unary operators.
   */

  exports.Methods = {
    Length: 'Length',
    ToUpperCase: 'ToUpperCase',
    ToLowerCase: 'ToLowerCase',
    Trim: 'Trim',
    IndexOf: 'IndexOf',
    Replace: 'Replace',
    Substring: 'Substring',
    Concat: 'Concat',
    Day: 'Day',
    Month: 'Month',
    Year: 'Year',
    Floor: 'Floor',
    Ceiling: 'Ceiling',
    Round: 'Round'
  };


  /*
   * Represents a literal string in the query language.
   */

  exports.LiteralExpression = LiteralExpression = (function(superClass) {
    extend(LiteralExpression, superClass);


    /*
     * @queryString
     * @args
     */

    function LiteralExpression(queryString, args) {
      this.queryString = queryString;
      this.args = args != null ? args : [];
      LiteralExpression.__super__.constructor.call(this);
    }

    return LiteralExpression;

  })(QueryExpression);

  QueryExpressionVisitor.prototype.LiteralExpression = function(node) {
    return this.QueryExpression(node);
  };

}).call(this);
