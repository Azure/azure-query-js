// Generated by CoffeeScript 1.10.0

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */


/* Pull in references */

(function() {
  var JavaScript, ODataProvider, Q, Query, _,
    slice = [].slice;

  _ = require('./Utilities');

  Q = require('./QueryNodes');

  JavaScript = require('./JavaScript').JavaScript;


  /*
   * Define a query that can be translated into a desired query language and
   * executed remotely.
   */

  exports.Query = Query = (function() {
    function Query(table, context) {
      var _context, _filters, _includeDeleted, _includeTotalCount, _orderClauses, _ordering, _projection, _selections, _skip, _table, _take, _version;
      if (!table || !(_.isString(table))) {
        throw 'Expected the name of a table!';
      }

      /* Store the table name and any extra context */
      _table = table;
      _context = context;

      /* Private Query component members */
      _filters = null;
      _projection = null;
      _selections = [];
      _ordering = {};
      _orderClauses = [];
      _skip = null;
      _take = null;
      _includeTotalCount = false;
      _includeDeleted = false;

      /*
       * Keep a version flag that's updated on each mutation so we can
       * track whether changes have been made.  This is to enable caching
       * of compiled queries without reevaluating unless necessary.
       */
      _version = 0;

      /* Get the individual components of the query */
      this.getComponents = function() {
        return {
          filters: _filters,
          selections: _selections,
          projection: _projection,
          ordering: _ordering,
          orderClauses: _orderClauses,
          skip: _skip,
          take: _take,
          table: _table,
          context: _context,
          includeTotalCount: _includeTotalCount,
          includeDeleted: _includeDeleted,
          version: _version
        };
      };

      /*
       * Set the individual components of the query (this is primarily
       * meant to be used for rehydrating a query).
       */
      this.setComponents = function(components) {
        var ascending, i, len, name, property, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
        _version++;
        _filters = (ref = components != null ? components.filters : void 0) != null ? ref : null;
        _selections = (ref1 = components != null ? components.selections : void 0) != null ? ref1 : [];
        _projection = (ref2 = components != null ? components.projection : void 0) != null ? ref2 : null;
        _skip = (ref3 = components != null ? components.skip : void 0) != null ? ref3 : null;
        _take = (ref4 = components != null ? components.take : void 0) != null ? ref4 : null;
        _includeTotalCount = (ref5 = components != null ? components.includeTotalCount : void 0) != null ? ref5 : false;
        _includeDeleted = (ref6 = components != null ? components.includeDeleted : void 0) != null ? ref6 : false;
        _table = (ref7 = components != null ? components.table : void 0) != null ? ref7 : null;
        _context = (ref8 = components != null ? components.context : void 0) != null ? ref8 : null;
        if (components != null ? components.orderClauses : void 0) {
          _orderClauses = (ref9 = components != null ? components.orderClauses : void 0) != null ? ref9 : [];
          _ordering = {};
          for (i = 0, len = _orderClauses.length; i < len; i++) {
            ref10 = _orderClauses[i], name = ref10.name, ascending = ref10.ascending;
            _ordering[name] = ascending;
          }
        } else {
          _ordering = (ref11 = components != null ? components.ordering : void 0) != null ? ref11 : {};
          _orderClauses = [];
          for (property in _ordering) {
            _orderClauses.push({
              name: property,
              ascending: !!_ordering[property]
            });
          }
        }
        return this;
      };

      /*
       * Add a constraint to a query.  Constraints can take the form of
       * a function with a single return statement, key/value pairs of
       * equality comparisons, or provider-specific literal strings (note
       * that not all providers support literals).
       */
      this.where = function() {
        var args, constraint, expr, name, value;
        constraint = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        _version++;

        /*
         * Translate the constraint from its high level form into a
         * QueryExpression tree that can be manipulated by a query
         * provider
         */
        expr = (function() {
          if (_.isFunction(constraint)) {
            return JavaScript.transformConstraint(constraint, args);
          } else if (_.isObject(constraint)) {

            /*
             * Turn an object of key value pairs into a series of
             * equality expressions that are and'ed together to form
             * a single expression
             */
            return Q.QueryExpression.groupClauses(Q.BinaryOperators.And, (function() {
              var results;
              results = [];
              for (name in constraint) {
                value = constraint[name];
                results.push(expr = new Q.BinaryExpression(Q.BinaryOperators.Equal, new Q.MemberExpression(name), new Q.ConstantExpression(value)));
              }
              return results;
            })());
          } else if (_.isString(constraint)) {

            /*
             * Store the literal query along with any arguments for
             * providers that support basic string replacement (i.e.,
             * something like where('name eq ?', 'Steve'))
             */
            return new Q.LiteralExpression(constraint, args);
          } else {
            throw "Expected a function, object, or string, not " + constraint;
          }
        })();

        /* Merge the new filters with any existing filters */
        _filters = Q.QueryExpression.groupClauses(Q.BinaryOperators.And, [_filters, expr]);
        return this;
      };

      /*
       * Project the query results.  A projection can either be defined as
       * a set of fields that we'll pull back (instead of the entire row)
       * or a function that will transform a row into a new type.  If a
       * function is used, we'll analyze the function to pull back the
       * minimal number of fields required.
       */
      this.select = function() {
        var i, len, param, parameters, projectionOrParameter;
        projectionOrParameter = arguments[0], parameters = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        _version++;
        if (_.isString(projectionOrParameter)) {

          /* Add all the literal string parameters */
          _selections.push(projectionOrParameter);
          for (i = 0, len = parameters.length; i < len; i++) {
            param = parameters[i];
            if (!(_.isString(param))) {
              throw "Expected string parameters, not " + param;
            }
            _selections.push(param);
          }
        } else if (_.isFunction(projectionOrParameter)) {

          /* Set the projection and calculate the fields it uses */
          _projection = projectionOrParameter;
          _selections = JavaScript.getProjectedFields(_projection);
        } else {
          throw "Expected a string or a function, not " + projectionOrParameter;
        }
        return this;
      };
      this.orderBy = function() {
        var i, j, len, len1, order, param, parameters, replacement;
        parameters = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        _version++;
        for (i = 0, len = parameters.length; i < len; i++) {
          param = parameters[i];
          if (!(_.isString(param))) {
            throw "Expected string parameters, not " + param;
          }
          _ordering[param] = true;
          replacement = false;
          for (j = 0, len1 = _orderClauses.length; j < len1; j++) {
            order = _orderClauses[j];
            if (order.name === param) {
              replacement = true;
              order.ascending = true;
            }
          }
          if (!replacement) {
            _orderClauses.push({
              name: param,
              ascending: true
            });
          }
        }
        return this;
      };
      this.orderByDescending = function() {
        var i, j, len, len1, order, param, parameters, replacement;
        parameters = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        _version++;
        for (i = 0, len = parameters.length; i < len; i++) {
          param = parameters[i];
          if (!(_.isString(param))) {
            throw "Expected string parameters, not " + param;
          }
          _ordering[param] = false;
          replacement = false;
          for (j = 0, len1 = _orderClauses.length; j < len1; j++) {
            order = _orderClauses[j];
            if (order.name === param) {
              replacement = true;
              order.ascending = false;
            }
          }
          if (!replacement) {
            _orderClauses.push({
              name: param,
              ascending: false
            });
          }
        }
        return this;
      };
      this.skip = function(count) {
        _version++;
        if (!(_.isNumber(count))) {
          throw "Expected a number, not " + count;
        }
        _skip = count;
        return this;
      };
      this.take = function(count) {
        _version++;
        if (!(_.isNumber(count))) {
          throw "Expected a number, not " + count;
        }
        _take = count;
        return this;
      };

      /*
       * Indicate that the query should include the total count for all the
       * records that would have been returned ignoring any take paging
       * limit clause specified by client or server.
       */
      this.includeTotalCount = function() {
        _version++;
        _includeTotalCount = true;
        return this;
      };

      /*
       * Indicate that the query should include soft deleted records.
       */
      this.includeDeleted = function() {
        _version++;
        _includeDeleted = true;
        return this;
      };
    }


    /*
     * Static method to register custom provider types.  A custom provider is
     * an object with a toQuery method that takes a Query instance and
     * returns a compiled query for that provider.
     */

    Query.registerProvider = function(name, provider) {
      Query.Providers[name] = provider;
      return Query.prototype["to" + name] = function() {
        return provider != null ? typeof provider.toQuery === "function" ? provider.toQuery(this) : void 0 : void 0;
      };
    };


    /*
     * Expose the registered providers via the Query.Providers namespace.
     */

    Query.Providers = {};


    /*
     * Expose the query expressions and visitors externally via a
     * Query.Expressions namespace.
     */

    Query.Expressions = Q;

    return Query;

  })();


  /* Register the built in OData provider */

  ODataProvider = require('./ODataProvider').ODataProvider;

  Query.registerProvider('OData', new ODataProvider);

}).call(this);
