// Generated by CoffeeScript 1.10.0

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */

(function() {
  var JS, JavaScript, JavaScriptToQueryVisitor, PartialEvaluator, esprima;

  esprima = require('esprima');

  JS = require('./JavaScriptNodes');

  PartialEvaluator = require('./PartialEvaluator').PartialEvaluator;

  JavaScriptToQueryVisitor = require('./JavaScriptToQueryVisitor').JavaScriptToQueryVisitor;


  /*
   * Define operations on JavaScript
   */

  exports.JavaScript = JavaScript = (function() {
    function JavaScript() {}


    /*
     * Static method to transform a constraint specified as a function into
     * a QueryExpression tree.
     */

    JavaScript.transformConstraint = function(func, env) {

      /*
       * Parse the body of the function into a JavaScriptExpression tree
       * (into a context that also contains its source and manually reified
       * environment)
       */
      var context, translator;
      context = JavaScript.getExpression(func, env);

      /*
       * Evaluate any independent subexpressions and turn them into
       * literals.
       */
      context.expression = PartialEvaluator.evaluate(context);

      /*
       * Convert the JavaScriptExpression tree into a QueryExpression tree
       */
      translator = new JavaScriptToQueryVisitor(context);
      return translator.visit(context.expression);
    };


    /*
     * Static method to walk a projection specified as a function and
     * determine which fields it uses.
     */

    JavaScript.getProjectedFields = function(func) {

      /*
       * This currently returns an empty array which indicates all fields.
       * At some point we'll need to go through and walk the expression
       * tree for func and see exactly which fields it uses.  This is
       * complicated by the fact that we support arbitrary expressions and
       * could for example pass 'this' to a nested lambda which means we
       * can't just check for MemberExpressions (though in that case we'll
       * probably just default to [] rather than trying to do alias
       * analysis across function calls, etc.)
       */
      return [];
    };


    /*
     * Turn a function and its explicitly passed environment into an
     * expression tree
     */

    JavaScript.getExpression = function(func, env) {

      /*
       * An anonymous function isn't considered a valid program, so we'll wrap
       * it in an assignment statement to keep the parser happy
       */
      var environment, expr, i, j, len, name, names, program, ref, ref1, ref10, ref11, ref12, ref13, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, source;
      source = "var _$$_stmt_$$_ = " + func + ";";

      /*
       * Use esprima to parse the source of the function body (and have it
       * return source locations in character ranges )
       */
      program = esprima.parse(source, {
        range: true

        /*
         * Get the expression from return statement of the function body to use
         * as our lambda expression
         */
      });
      expr = (program != null ? program.type : void 0) === 'Program' && (program != null ? (ref = program.body) != null ? ref.length : void 0 : void 0) === 1 && ((ref1 = program.body[0]) != null ? ref1.type : void 0) === 'VariableDeclaration' && ((ref2 = program.body[0]) != null ? (ref3 = ref2.declarations) != null ? ref3.length : void 0 : void 0) === 1 && ((ref4 = program.body[0].declarations[0]) != null ? ref4.type : void 0) === 'VariableDeclarator' && ((ref5 = program.body[0].declarations[0]) != null ? (ref6 = ref5.init) != null ? ref6.type : void 0 : void 0) === 'FunctionExpression' && ((ref7 = program.body[0].declarations[0].init) != null ? (ref8 = ref7.body) != null ? ref8.type : void 0 : void 0) === 'BlockStatement' && ((ref9 = program.body[0].declarations[0].init.body) != null ? (ref10 = ref9.body) != null ? ref10.length : void 0 : void 0) === 1 && ((ref11 = program.body[0].declarations[0].init.body.body[0]) != null ? ref11.type : void 0) === 'ReturnStatement' && ((ref12 = program.body[0].declarations[0].init.body.body[0]) != null ? ref12.argument : void 0);
      if (!expr) {
        throw "Expected a predicate with a single return statement, not " + func;
      }

      /*
       * Create the environment mqpping parameters to values
       */
      names = (ref13 = program.body[0].declarations[0].init.params) != null ? ref13.map(function(p) {
        return p.name;
      }) : void 0;
      if (names.length > env.length) {
        throw "Expected value(s) for parameter(s) " + names.slice(env.length);
      } else if (env.length > names.length) {
        throw "Expected parameter(s) for value(s) " + env.slice(names.length);
      }
      environment = {};
      for (i = j = 0, len = names.length; j < len; i = ++j) {
        name = names[i];
        environment[name] = env[i];
      }
      return {

        /*
         * Return the environment context
         */
        source: source,
        expression: expr,
        environment: environment
      };
    };

    return JavaScript;

  })();

}).call(this);
