// Generated by CoffeeScript 1.7.1

/*
 * ----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * ----------------------------------------------------------------------------
 */

(function() {
  var JS, JavaScript, JavaScriptToQueryVisitor, PartialEvaluator, esprima;

  esprima = require('esprima');

  JS = require('./JavaScriptNodes');

  PartialEvaluator = require('./PartialEvaluator').PartialEvaluator;

  JavaScriptToQueryVisitor = require('./JavaScriptToQueryVisitor').JavaScriptToQueryVisitor;


  /*
   * Define operations on JavaScript
   */

  exports.JavaScript = JavaScript = (function() {
    function JavaScript() {}


    /*
     * Static method to transform a constraint specified as a function into
     * a QueryExpression tree.
     */

    JavaScript.transformConstraint = function(func, env) {

      /*
       * Parse the body of the function into a JavaScriptExpression tree
       * (into a context that also contains its source and manually reified
       * environment)
       */
      var context, translator;
      context = JavaScript.getExpression(func, env);

      /*
       * Evaluate any independent subexpressions and turn them into
       * literals.
       */
      context.expression = PartialEvaluator.evaluate(context);

      /*
       * Convert the JavaScriptExpression tree into a QueryExpression tree
       */
      translator = new JavaScriptToQueryVisitor(context);
      return translator.visit(context.expression);
    };


    /*
     * Static method to walk a projection specified as a function and
     * determine which fields it uses.
     */

    JavaScript.getProjectedFields = function(func) {

      /*
       * This currently returns an empty array which indicates all fields.
       * At some point we'll need to go through and walk the expression
       * tree for func and see exactly which fields it uses.  This is
       * complicated by the fact that we support arbitrary expressions and
       * could for example pass 'this' to a nested lambda which means we
       * can't just check for MemberExpressions (though in that case we'll
       * probably just default to [] rather than trying to do alias
       * analysis across function calls, etc.)
       */
      return [];
    };


    /*
     * Turn a function and its explicitly passed environment into an
     * expression tree
     */

    JavaScript.getExpression = function(func, env) {

      /*
       * An anonymous function isn't considered a valid program, so we'll wrap
       * it in an assignment statement to keep the parser happy
       */
      var environment, expr, i, name, names, program, source, _i, _len, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      source = "var _$$_stmt_$$_ = " + func + ";";

      /*
       * Use esprima to parse the source of the function body (and have it
       * return source locations in character ranges )
       */
      program = esprima.parse(source, {
        range: true
      });

      /*
       * Get the expression from return statement of the function body to use
       * as our lambda expression
       */
      expr = (program != null ? program.type : void 0) === 'Program' && (program != null ? (_ref = program.body) != null ? _ref.length : void 0 : void 0) === 1 && ((_ref1 = program.body[0]) != null ? _ref1.type : void 0) === 'VariableDeclaration' && ((_ref2 = program.body[0]) != null ? (_ref3 = _ref2.declarations) != null ? _ref3.length : void 0 : void 0) === 1 && ((_ref4 = program.body[0].declarations[0]) != null ? _ref4.type : void 0) === 'VariableDeclarator' && ((_ref5 = program.body[0].declarations[0]) != null ? (_ref6 = _ref5.init) != null ? _ref6.type : void 0 : void 0) === 'FunctionExpression' && ((_ref7 = program.body[0].declarations[0].init) != null ? (_ref8 = _ref7.body) != null ? _ref8.type : void 0 : void 0) === 'BlockStatement' && ((_ref9 = program.body[0].declarations[0].init.body) != null ? (_ref10 = _ref9.body) != null ? _ref10.length : void 0 : void 0) === 1 && ((_ref11 = program.body[0].declarations[0].init.body.body[0]) != null ? _ref11.type : void 0) === 'ReturnStatement' && ((_ref12 = program.body[0].declarations[0].init.body.body[0]) != null ? _ref12.argument : void 0);
      if (!expr) {
        throw "Expected a predicate with a single return statement, not " + func;
      }

      /*
       * Create the environment mqpping parameters to values
       */
      names = (_ref13 = program.body[0].declarations[0].init.params) != null ? _ref13.map(function(p) {
        return p.name;
      }) : void 0;
      if (names.length > env.length) {
        throw "Expected value(s) for parameter(s) " + names.slice(env.length);
      } else if (env.length > names.length) {
        throw "Expected parameter(s) for value(s) " + env.slice(names.length);
      }
      environment = {};
      for (i = _i = 0, _len = names.length; _i < _len; i = ++_i) {
        name = names[i];
        environment[name] = env[i];
      }
      return {

        /*
         * Return the environment context
         */
        source: source,
        expression: expr,
        environment: environment
      };
    };

    return JavaScript;

  })();

}).call(this);
